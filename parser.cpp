
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <iostream>
#include "lexer.h"

// Forward declaration of getNextToken function
int getNextToken();
#include "parser.h"
 
using namespace std;

int nextToken = 0;            // hold nextToken returned by lex
// Which tree level are we currently in?  
static int level = 0;

// Feel free to use a different data structure for the symbol table (list of
// variables declared in the program) but you will have to adjust the code in
// main() to print out the symbol table after a successful parse
set<string> symbolTable; // Symbol Table

//*****************************************************************************
// Indent to reveal tree structure
string psp(void) { // Stands for p-space, but I want the name short
  string str("");
  for(int i = 0; i < level; i++)
    str += "|  ";
  return str;
};
//*****************************************************************************
// Report what we found
void output(string what) {
  cout << psp() << "found |" << yytext << "| " << what << endl;
}
//*****************************************************************************
// Forward declarations of FIRST_OF functions.  These check whether the current 
// token is in the FIRST set of a production rule.
bool first_of_program(void);
bool first_of_block(void);
bool first_of_statement(void);
bool first_of_compound_statement(void);
bool first_of_expression(void);
bool first_of_simple_expression(void);
bool first_of_term(void);
bool first_of_factor(void);
void program(void);
void block(void);
void statement(void);
void assignment_statement(void);
void if_statement(void);
void while_statement(void);
void read_statement(void);
void write_statement(void);
void compound_statement(void);
void expression(void);
void simple_expression(void);
void term(void);
void factor(void);

struct Node {
    Node* program();
    Node* block();
    Node* statement();
    Node* assignment_statement();
    Node* if_statement();
    Node* while_statement();
    Node* read_statement();
    Node* write_statement();
    Node* compound_statement();
    Node* expression();
    Node* simple_expression();
    Node* term();
    Node* factor();
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <program> → TOK_PROGRAM TOK_IDENT TOK_SEMICOLON <block>
ProgramNode* program() {
    if (!first_of_program()) // Check for PROGRAM
        throw "3: 'PROGRAM' expected";
    output("PROGRAM");
    nextToken = yylex(); // Get next token
    
    cout << psp() << "enter <program>" << endl;
    ++level;

    ProgramNode* newProgramNode = nullptr;
    // TODO: finish this parsing function...
    output("IDENTIFIER");
    nextToken = yylex();
    newProgramNode = new ProgramNode(yytext, IDENT);

    if (nextToken != TOK_SEMICOLON) {
        throw "14: ; expected";
    }
    output("SEMICOLON");
    nextToken = yylex();
    newProgramNode = new ProgramNode(yytext, IDENT);

    output("BLOCK");
    if (nextToken == TOK_BEGIN) {
        block();
    }
    else {
        nextToken = yylex();
        block();
    }

    --level;
    cout << psp() << "exit <program>" << endl;
}
    
bool first_of_program(void) {
    return nextToken == TOK_PROGRAM;
}

//*****************************************************************************
// Parses strings in the language generated by the rule:
// <block> → { <statement_list> }
BlockNode* block(void) {
    cout << psp() << "enter <block>" << endl;
    ++level;

    BlockNode* newBlockNode = nullptr;
    // TODO: finish this parsing function...
    // Placeholder for block parsing logic " cout << "here" << yytext < endl; return;" " Read, write, assign, factor"
    // if(symbolTable.find(yytext) == symbolTable.end())
    //     throw "XX: Identifier declared twice";
    if (nextToken == TOK_BEGIN) {
        output("BEGIN");
        nextToken = yylex();
        newBlockNode = new BlockNode(yytext, BEGIN);
    }

    while (nextToken == TOK_IDENT) {
        string varName = yytext;
        output("IDENTIFIER");
        nextToken = yylex();
        newBlockNode = new BlockNode(yytext, IDENT);

        if (nextToken == TOK_COLON) {
        output("COLON");
        nextToken = yylex();
        newBlockNode = new BlockNode(";", COLON);
        }

        string varType = yytext;
        output("TYPE");
        nextToken = yylex();

        if (nextToken == TOK_SEMICOLON) {
        output("SEMICOLON");
        nextToken = yylex();
        newBlockNode = new BlockNode(";", SEMICOLON);
        }

        cout << psp() <<"-- idName: |" << varName << "| idType: |" << varType << "| --" << std::endl;

        if (symbolTable.insert(varName).second == false) 
            throw "104: Identifier not declared";
        

    }

    if (nextToken == TOK_BEGIN) {
        output("BEGIN");
        nextToken = yylex();
    }

    compound_statement();

    --level;
    cout << psp() << "exit <block>" << endl;
}

bool first_of_block(void) {
    return nextToken == TOK_OPENPAREN;
} 

StatementNode* statement() {
    output("STATEMENT");

    if (nextToken == TOK_IDENT) {
        assignment_statement();
    } 
    if (nextToken == TOK_IF) {
        if_statement();
    } 
    if (nextToken == TOK_WHILE) {
        while_statement();
    } 
    if (nextToken == TOK_READ) {
        read_statement();
    } 
    if (nextToken == TOK_WRITE) {
        write_statement();
    } 
    if (nextToken == TOK_BEGIN) {
        compound_statement();
    } 
}

bool first_of_statement(void) {
    return nextToken == TOK_IDENT;
}


AssignmentNode* assignment_statement() {
    cout << psp() << "enter <assignment>" << endl;
    ++level;

    AssignmentNode* newAssignmentNode = nullptr;

    output("IDENTIFIER");
    cout << psp() << yytext << endl;
    if (nextToken != TOK_IDENT) {
        throw "2: identifier expected";
    }
    newAssignmentNode = new AssignmentNode(yytext, IDENT);
    nextToken = yylex();

    output("ASSIGN");
    if (nextToken != TOK_ASSIGN) {
        throw "999: an error has occurred";
    }
    newAssignmentNode = new AssignmentNode(yytext, ASSIGN);
    nextToken = yylex();j

    output("EXPRESSION");
    expression();

    if (nextToken != TOK_SEMICOLON) {
        throw "14: ; expected";
    }

    --level;
    cout << psp() << "exit <assignment>" << endl;
    
    return newAssignmentNode;
}

ThenNode* then() {
    cout << psp() << "enter <then>" << endl;
    ++level;

    ThenNode* newThenNode = nullptr;

    statement();

    --level;
    cout << psp() << "exit <then>" << endl;

    return newThenNode;
}

ElseNode* else_statement() {
    cout << psp() << "enter <else>" << endl;
    ++level;

    ElseNode* newElseNode = nullptr;

    statement();

    --level;
    cout << psp() << "exit <else>" << endl;

    return newElseNode;
}

IfNode* if_statement() {
    cout << psp() << "enter <if>" << endl;
    ++level;

    IfNode* newIfNode = nullptr;

    if (nextToken != TOK_IF) {
        throw "999: an error has occurred";
    }
    nextToken = yylex();
    output("EXPRESSION");
    expression();

    if (nextToken == TOK_THEN) {
        --level;
        output("THEN");
        nextToken = yylex();
        then();
    }
    
    if (nextToken == TOK_ELSE) {
        output("ELSE");
        nextToken = yylex();
        else_statement();
    }

    cout << psp() << "exit <if>" << endl;

    return newIfNode;
}

WhileNode* while_statement() {
    cout << psp() << "enter <while>" << endl;
    ++level;

    WhileNode* newWhileNode = nullptr;

    if (nextToken != TOK_WHILE) {
        throw "999: an error has occurred";
    }
    nextToken = yylex();

    output("EXPRESSION");
    expression();

    statement();

    --level;
    cout << psp() << "exit <while>" << endl;

    return newWhileNode;
}

ReadNode* read_statement() {
    
    cout << psp() << "enter <read>" << endl;
    ++level;
    
    ReadNode* newReadNode = nullptr;

    if (nextToken == TOK_READ) {
        output("READ");
        nextToken = yylex();
    }

    if (nextToken == TOK_OPENPAREN) {
        output("OPENPAREN");
        nextToken = yylex();

        output("IDENTIFIER");
        cout << psp() << yytext << endl;    
        nextToken = yylex();

        output("CLOSEPAREN");
        nextToken = yylex();
    }

    --level;
    cout << psp() << "exit <read>" << endl;

    return newReadNode;
}

WriteNode* write_statement() {
    cout << psp() << "enter <write>" << endl;
    ++level;

    WriteNode* newWriteNode = nullptr;

    nextToken = yylex();
    output("OPENPAREN");
    nextToken = yylex();

    output("WRITE");
    cout << psp() << yytext << endl;
    nextToken = yylex(); 

    output("CLOSEPAREN");
    nextToken = yylex();

    --level;
    cout << psp() << "exit <write>" << endl;

    return newWriteNode;
}

CompoundNode* compound_statement() {
    cout << psp() << "enter <compound_stmt>" << endl;
    ++level;

    CompoundNode* newCompoundNode = nullptr;

    statement();

    while(nextToken == TOK_SEMICOLON){
        output("SEMICOLON");
        nextToken = yylex();
        statement();
    }

    --level;
    output("END");
    nextToken = yylex();

    cout << psp() << "exit <compound_stmt>" << endl;

    return newCompoundNode;
}

bool first_of_compound_statement(void) {
    return nextToken == TOK_BEGIN;
}

ExprNode* expression() {
    cout << psp() << "enter <expression>" << endl;
    ++level;

    ExprNode* newExprNode = nullptr;

    output("SIMPLE_EXP");
    simple_expression();

    if (nextToken == TOK_EQUALTO) {
        output("EQUALTO");
        cout << psp() << yytext << endl;
        newExprNode = new ExprNode(yytext, EQUALTO);
        nextToken = yylex();
    }
    else if (nextToken == TOK_LESSTHAN) {
        output("LESSTHAN");
        cout << psp() << yytext << endl;
        newExprNode = new ExprNode(yytext, LESSTHAN);
        nextToken = yylex();
        
    }
    else if (nextToken == TOK_GREATERTHAN) {
        output("GREATERTHAN");
        cout << psp() << yytext << endl;
        newExprNode = new ExprNode(yytext, GREATERTHAN);
        nextToken = yylex();
    }
    else if (nextToken == TOK_NOTEQUALTO) {
        output("NOTEQUALTO");
        cout << psp() << yytext << endl;
        newExprNode = new ExprNode(yytext, NOTEQUALTO);
        nextToken = yylex();
    }
    output("SIMPLE_EXP");
    simple_expression();
    --level;
    cout << psp() << "exit <expression>" << endl;

    return newExprNode;
}

bool first_of_expression(void) {
    return nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN;
}

SimpleExprNode* simple_expression() {
    cout << psp() << "enter <simple_exp>" << endl;
    ++level;

    SimpleExprNode* newSimpleExprNode = nullptr;

    output("TERM");
    term();

    while (nextToken == TOK_PLUS || nextToken == TOK_MINUS || nextToken == TOK_OR) {
        nextToken = yylex();
        term();
    }

    --level;
    cout << psp() << "exit <simple_exp>" << endl;

    return newSimpleExprNode;
}

bool first_of_simple_expression(void) {
    return nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN;
}

TermNode* term() {
    cout << psp() << "enter <term>" << endl;
    ++level;

    TermNode* newTermNode = nullptr;

    output("FACTOR");
    factor();

    while (nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE || nextToken == TOK_MOD || nextToken == TOK_AND) {
        if (nextToken == TOK_MULTIPLY) {
            output("MULTIPLY");
            cout << psp() << yytext << endl;
        }
        else if (nextToken == TOK_DIVIDE) {
            output("DIVIDE");
            cout << psp() << yytext << endl;
        }
        else if (nextToken == TOK_MOD) {
            output("MOD");
            cout << psp() << yytext << endl;
        }
        else if (nextToken == TOK_AND) {
            output("AND");
            cout << psp() << yytext << endl;
        }
        nextToken = yylex();
        output("FACTOR");
        factor();
    }

    while (nextToken == TOK_MULTIPLY) {
        output("MULTIPLY");
        cout << psp() << yytext << endl;
        nextToken = yylex();
        output("FACTOR");
        factor();
    }

    --level;
    cout << psp() << "exit <term>" << endl;

    return newTermNode;
}

bool first_of_term(void) {
    return nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN;
}

FactorNode* factor() {
    cout << psp() << "enter <factor>" << endl;
    ++level;

    FactorNode* newFactorNode = nullptr;

    if (nextToken == TOK_INTLIT) {
        output("INTLIT");
        cout << psp() << yytext << endl;
        newFactorNode = new FactorNode(yytext, INTLIT);
        nextToken = yylex();
    }
    else if (nextToken == TOK_FLOATLIT) {
        output("FLOATLIT");
        cout << psp() << yytext << endl;
        newFactorNode = new FactorNode(yytext, FLOATLIT);
        nextToken = yylex();
    }
     else if (nextToken == TOK_IDENT) {
        output("IDENTIFIER");
        cout << psp() << yytext << endl;
        if (symbolTable.find(yytext) == symbolTable.end())
	        throw ("104: identifier not declared");
        newFactorNode = new FactorNode(yytext, IDENT);
        nextToken = yylex();
    }
    else if (nextToken == TOK_MINUS) {
        output("MINUS");
        cout << psp() << yytext << endl;
        nextToken = yylex();
        output("FACTOR");
        if (nextToken == TOK_MINUS || nextToken == TOK_NOT) {
            throw "999: an error has occurred";
        }
        factor();
        newFactorNode = new FactorNode("-", MINUS);
    }
    else if (nextToken == TOK_NOT) {
        output("NOT");
        cout << psp() << yytext << endl;
        nextToken = yylex();
        if (nextToken == TOK_MINUS || nextToken == TOK_NOT) {
            throw "999: an error has occurred";
        }
        factor();
        newFactorNode = new FactorNode("!", NOT);
    }
    else if (nextToken == TOK_OPENPAREN) {
        output("OPENPAREN");
        cout << psp() << yytext << endl;
        nextToken = yylex();
        FactorNode* exprNode = expression();
        if (nextToken == TOK_CLOSEPAREN) {
            output("CLOSEPAREN");
            cout << psp() << yytext << endl;
            nextToken = yylex();
            newFactorNode = new FactorNode(exprNode);
        }
        else {
            throw "7: ')' expected";
        }
    }

    --level;
    cout << psp() << "exit <factor>" << endl;

    return newFactorNode;
}

bool first_of_factor(void) {
    return nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN;
}









